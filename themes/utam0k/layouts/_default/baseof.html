{{ $styles := resources.Get "css/main.css" | resources.Minify | resources.Fingerprint }}
{{ $desc := "" }}
{{ if .Description }}
  {{ $desc = .Description | plainify }}
{{ else if .IsPage }}
  {{ $desc = .Summary | plainify }}
{{ else }}
  {{ $desc = .Site.Params.description }}
{{ end }}
<!DOCTYPE html>
<html lang="{{ .Site.Language.Lang }}">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>{{ block "title" . }}{{ if .IsHome }}{{ .Site.Title }}{{ else }}{{ .Title }} | {{ .Site.Title }}{{ end }}{{ end }}</title>
  <meta name="description" content="{{ $desc }}">
  <meta property="og:description" content="{{ $desc }}">
  <meta property="og:type" content="{{ if .IsPage }}article{{ else }}website{{ end }}">
  <meta property="og:site_name" content="{{ .Site.Title }}">
  {{ with .Permalink }}<meta property="og:url" content="{{ . }}">{{ end }}
  {{ with .Title }}<meta property="og:title" content="{{ . }}">{{ end }}
  {{ with .Params.image | default .Site.Params.logo }}<meta property="og:image" content="{{ . | absURL }}">{{ end }}
  <link rel="alternate" type="application/rss+xml" href="{{ "index.xml" | relLangURL }}">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=PT+Sans:wght@400;700&family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/hack-font/3.3.0/web/hack.min.css" crossorigin="anonymous">
  <link rel="stylesheet" href="{{ $styles.RelPermalink }}" integrity="{{ $styles.Data.Integrity }}">
  <script>
    (() => {
      const media = window.matchMedia('(prefers-color-scheme: dark)');
      const syncToggleButton = (mode) => {
        const options = document.querySelectorAll('.theme-option');
        options.forEach((opt) => {
          const isActive = opt.dataset.mode === mode;
          opt.setAttribute('aria-pressed', isActive ? 'true' : 'false');
        });
        const single = document.querySelector('.theme-toggle');
        if (single) single.setAttribute('aria-pressed', mode === 'dark' ? 'true' : 'false');
        const choices = document.querySelectorAll('.theme-choice');
        choices.forEach((c) => c.setAttribute('aria-checked', c.dataset.mode === mode ? 'true' : 'false'));
        const icon = document.querySelector('[data-theme-icon]');
        if (icon) {
          const effectiveState = mode === 'system' ? document.documentElement.dataset.theme || 'light' : mode;
          icon.dataset.state = effectiveState;
        }
      };
      const resolve = (mode) => mode === 'system' ? (media.matches ? 'dark' : 'light') : mode;
      const apply = (mode) => {
        const effective = resolve(mode);
        document.documentElement.dataset.theme = effective;
        if (document.body) {
          document.body.dataset.theme = effective;
          document.body.classList.toggle('theme-dark', effective === 'dark');
          document.body.classList.toggle('theme-light', effective === 'light');
        }
        syncToggleButton(mode);
      };
      const load = () => {
        const stored = localStorage.getItem('color-scheme');
        const initial = stored || 'system';
        apply(initial);
      };
      media.addEventListener('change', (e) => {
        const stored = localStorage.getItem('color-scheme');
        if (!stored || stored === 'system') apply('system');
      });
      window.__setTheme = (mode) => {
        const next = mode || (document.documentElement.dataset.theme === 'dark' ? 'light' : 'dark');
        localStorage.setItem('color-scheme', next);
        apply(next);
      };
      window.__toggleTheme = () => window.__setTheme();
      window.__toggleThemeMenu = (btn) => {
        const pop = btn?.nextElementSibling;
        if (!pop) return;
        const isOpen = !pop.hidden;
        document.querySelectorAll('.theme-popover').forEach(el => el.hidden = true);
        document.querySelectorAll('.theme-trigger').forEach(el => el.setAttribute('aria-expanded','false'));
        if (!isOpen) {
          pop.hidden = false;
          btn.setAttribute('aria-expanded','true');
        }
      };
      document.addEventListener('click', (e) => {
        const pop = document.querySelector('.theme-popover');
        if (!pop) return;
        if (e.target.closest('.theme-menu')) return;
        pop.hidden = true;
        const trig = document.querySelector('.theme-trigger');
        trig?.setAttribute('aria-expanded','false');
      });

      /* Language popover */
      window.__toggleLangMenu = (btn) => {
        const pop = btn?.nextElementSibling;
        if (!pop) return;
        const isOpen = !pop.hidden;
        document.querySelectorAll('.lang-popover').forEach(el => el.hidden = true);
        document.querySelectorAll('.lang-trigger').forEach(el => el.setAttribute('aria-expanded','false'));
        if (!isOpen) {
          pop.hidden = false;
          btn.setAttribute('aria-expanded','true');
        }
      };
      window.__switchLang = (url, label) => {
        if (!url) return;
        window.location.href = url;
      };
      document.addEventListener('click', (e) => {
        const pop = document.querySelector('.lang-popover');
        if (!pop) return;
        if (e.target.closest('.lang-menu')) return;
        pop.hidden = true;
        const trig = document.querySelector('.lang-trigger');
        trig?.setAttribute('aria-expanded','false');
      });
      load();
      document.addEventListener('DOMContentLoaded', () => {
        const initial = document.documentElement.dataset.theme || (media.matches ? 'dark' : 'light');
        syncToggleButton(initial);
      });
    })();
  </script>
  {{ hugo.Generator }}
  {{ with site.Config.Services.GoogleAnalytics.ID }}
  <script async src="https://www.googletagmanager.com/gtag/js?id={{ . }}"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', '{{ . }}');
  </script>
  {{ end }}
</head>
{{ $toc := .TableOfContents }}
{{ $hasToc := gt (len ($toc | plainify)) 0 }}
<body class="{{ if .IsHome }}home{{ else if eq .Kind "404" }}error404{{ else }}page{{ end }}" data-has-toc="{{ if $hasToc }}true{{ else }}false{{ end }}">
  <div class="page-shell">
    {{ partial "header.html" . }}
    <main class="layout">
      {{ block "main" . }}{{ end }}
    </main>
    {{ partial "footer.html" . }}
  </div>

  {{ if or .Params.math ( default true .Site.Params.math ) }}
  <script defer src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <script defer type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });</script>
  {{ end }}

  <script>
    // Mobile detection helper (width or UA); sets body.dataset.isMobile
    (() => {
      const detect = () => {
        const mq = window.matchMedia('(max-width: 1024px)').matches;
        const ua = /Mobi|Android/i.test(navigator.userAgent);
        const isMobile = mq || ua;
        document.body.dataset.isMobile = isMobile ? 'true' : 'false';
      };
      detect();
      window.addEventListener('resize', detect, { passive: true });
    })();

    // Mobile TOC floating button + modal (overlay close, toggle, auto-close on nav, button label swap, swipe to close)
    (() => {
      const btns = () => Array.from(document.querySelectorAll('[data-toc-modal]'));
      const modals = () => Array.from(document.querySelectorAll('.toc-modal'));
      const overlays = () => Array.from(document.querySelectorAll('.toc-modal__overlay'));
      const btnsForModal = (modal) => btns().filter((b) => b.dataset.tocModal === `#${modal?.id}`);
      const setBtnState = (modal, isOpen) => {
        btnsForModal(modal).forEach((b) => {
          b.classList.toggle('is-active', isOpen);
          b.setAttribute('aria-pressed', isOpen ? 'true' : 'false');
        });
      };

      const openModal = (modal) => {
        if (!modal) return;
        modal.classList.add('is-open');
        modal.hidden = false;
        document.body.classList.add('toc-open');
        setBtnState(modal, true);
      };
      const closeModal = (modal) => {
        if (!modal) return;
        modal.style.transform = '';
        modal.classList.remove('is-open');
        modal.hidden = true;
        document.body.classList.remove('toc-open');
        setBtnState(modal, false);
      };
      const closeAll = () => modals().forEach((m) => closeModal(m));
      const toggleModal = (modal) => {
        if (!modal) return;
        modal.classList.contains('is-open') ? closeModal(modal) : openModal(modal);
      };
      const showOnScroll = () => {
        btns().forEach((b) => b.classList.add('is-visible'));
      };

      // Swipe down to close
      const setupSwipe = (modal) => {
        let startY = 0;
        let currentY = 0;
        let isDragging = false;
        const threshold = 80;

        const onTouchStart = (e) => {
          // Only start drag from handle or header area, or when scrolled to top
          const handle = modal.querySelector('.toc-modal__handle');
          const header = modal.querySelector('.toc-modal__header');
          const isHandleOrHeader = handle?.contains(e.target) || header?.contains(e.target);
          const isScrolledToTop = modal.scrollTop <= 0;

          if (!isHandleOrHeader && !isScrolledToTop) return;

          isDragging = true;
          startY = e.touches[0].clientY;
          currentY = startY;
          modal.style.transition = 'none';
        };

        const onTouchMove = (e) => {
          if (!isDragging) return;
          currentY = e.touches[0].clientY;
          const deltaY = currentY - startY;

          // Only allow dragging down
          if (deltaY > 0) {
            modal.style.transform = `translateY(${deltaY}px)`;
            e.preventDefault();
          }
        };

        const onTouchEnd = () => {
          if (!isDragging) return;
          isDragging = false;
          modal.style.transition = '';

          const deltaY = currentY - startY;
          if (deltaY > threshold) {
            closeModal(modal);
          } else {
            modal.style.transform = '';
          }
        };

        modal.addEventListener('touchstart', onTouchStart, { passive: true });
        modal.addEventListener('touchmove', onTouchMove, { passive: false });
        modal.addEventListener('touchend', onTouchEnd, { passive: true });
      };

      const bind = () => {
        btns().forEach((b) => {
          b.addEventListener('click', () => {
            const sel = b.dataset.tocModal;
            const modal = sel ? document.querySelector(sel) : null;
            toggleModal(modal);
          });
        });
        // Setup swipe for each modal
        modals().forEach((m) => setupSwipe(m));
        // overlay click closes
        document.addEventListener('click', (e) => {
          if (e.target?.classList?.contains('toc-modal__overlay')) {
            closeAll();
          }
          if (e.target?.matches('[data-toc-close]')) {
            const modal = e.target.closest('.toc-modal');
            closeModal(modal);
          }
          // Click on TOC links auto-close
          if (e.target?.closest('.toc-modal') && e.target.tagName === 'A') {
            closeAll();
          }
        });
        window.addEventListener('scroll', showOnScroll, { passive: true });
        showOnScroll();
      };
      if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', bind);
      else bind();
    })();

    // Auto-hide header on scroll down, reveal on scroll up (desktop only)
    (() => {
      const header = document.querySelector('.site-header');
      if (!header) return;
      const isMobile = () => document.body.dataset.isMobile === 'true';
      if (isMobile()) return; // keep header fixed on mobile
      let lastY = window.scrollY;
      let ticking = false;
      const delta = 8;

      const update = () => {
        const y = window.scrollY;
        if (y < 80) {
          header.classList.remove('is-hidden');
          lastY = y;
          return;
        }
        if (Math.abs(y - lastY) < delta) return;
        if (y > lastY) header.classList.add('is-hidden');
        else header.classList.remove('is-hidden');
        lastY = y;
      };

      window.addEventListener('scroll', () => {
        if (ticking) return;
        ticking = true;
        requestAnimationFrame(() => { update(); ticking = false; });
      }, { passive: true });
    })();

    // Mobile share bar: float and reveal only while scrolling up
    (() => {
      const bar = document.querySelector('.share-block--mobile');
      if (!bar) return;
      const isMobile = () => document.body.dataset.isMobile === 'true';
      let lastY = window.scrollY;
      let ticking = false;
      const delta = 4;
      const threshold = 80;

      const enableFloating = () => {
        if (bar.classList.contains('is-floating')) return;
        bar.classList.add('is-floating');
        document.body.classList.add('has-mobile-share');
      };
      const disableFloating = () => {
        bar.classList.remove('is-floating', 'is-visible');
        document.body.classList.remove('has-mobile-share');
      };
      const update = () => {
        if (!isMobile()) { disableFloating(); return; }
        enableFloating();
        const y = window.scrollY;
        if (y < threshold) {
          bar.classList.add('is-visible');
          lastY = y;
          return;
        }
        if (Math.abs(y - lastY) < delta) return;
        const goingUp = y < lastY;
        if (goingUp) bar.classList.add('is-visible');
        else bar.classList.remove('is-visible');
        lastY = y;
      };

      window.addEventListener('scroll', () => {
        if (ticking) return;
        ticking = true;
        requestAnimationFrame(() => { update(); ticking = false; });
      }, { passive: true });
      window.addEventListener('resize', update, { passive: true });
      window.addEventListener('orientationchange', update, { passive: true });
      update();
    })();

    // Native share (mobile only; falls back to removal if unsupported)
    (() => {
      const btn = document.querySelector('[data-share-native]');
      if (!btn) return;
      const url = btn.dataset.shareUrl || location.href;
      const title = btn.dataset.shareTitle || document.title;
      const isMobile = () => document.body.dataset.isMobile === 'true';
      const enable = () => {
        btn.hidden = false;
        btn.addEventListener('click', async (e) => {
          e.preventDefault();
          try {
            await navigator.share({ title, url });
          } catch (err) {
            // Swallow aborts; keep the button even on failure so the user can retry
            if (err && err.name === 'AbortError') return;
            console.warn('Native share failed', err);
          }
        });
      };
      const evaluate = () => {
        if (navigator.share && isMobile()) enable();
        else btn.remove();
      };
      evaluate();
      window.addEventListener('resize', evaluate, { passive: true });
      window.addEventListener('orientationchange', evaluate, { passive: true });
    })();

    // Mobile menu toggle
    (() => {
      const btn = document.querySelector('[data-menu-toggle]');
      const menu = document.getElementById('mobile-menu');
      const overlay = document.querySelector('[data-menu-overlay]');
      if (!btn || !menu) return;
      const isMobile = () => document.body.dataset.isMobile === 'true';
      const setState = (open) => {
        btn.classList.toggle('is-open', open);
        btn.setAttribute('aria-expanded', open ? 'true' : 'false');
        menu.hidden = !open;
        menu.classList.toggle('is-open', open);
        if (overlay) {
          overlay.hidden = !open;
          overlay.classList.toggle('is-open', open);
        }
        document.body.classList.toggle('menu-open', open);
      };
      const toggle = () => setState(!(btn.getAttribute('aria-expanded') === 'true'));
      const close = () => setState(false);
      btn.addEventListener('click', (e) => { e.stopPropagation(); toggle(); });
      document.querySelectorAll('[data-menu-close]').forEach((c) => c.addEventListener('click', close));
      document.addEventListener('click', (e) => {
        if (!menu.contains(e.target) && !btn.contains(e.target)) close();
      });
      if (overlay) overlay.addEventListener('click', close);
      document.addEventListener('keydown', (e) => { if (e.key === 'Escape') close(); });
      window.addEventListener('resize', () => { if (!isMobile()) close(); }, { passive: true });
    })();
  </script>

  <script>
    // TOC scroll spy
    (() => {
      const tocLinks = Array.from(document.querySelectorAll('.toc__body a'));
      if (!tocLinks.length) return;

      const idFromLink = (a) => decodeURIComponent(a.hash.replace('#',''));
      const linksById = new Map();
      tocLinks.forEach((a) => {
        const id = idFromLink(a);
        const list = linksById.get(id) || [];
        list.push(a);
        linksById.set(id, list);
      });

      const headings = Array.from(new Set(
        tocLinks
          .map((a) => document.getElementById(idFromLink(a)))
          .filter(Boolean)
      ));
      if (!headings.length) return;

      const setActive = (id) => {
        linksById.forEach((links, key) => {
          links.forEach((l) => l.classList.toggle('is-active', key === id));
        });
      };

      const fallbackCalc = () => {
        const pos = window.scrollY + 120;
        let activeId = headings[0].id;
        for (const h of headings) {
          if (h.offsetTop <= pos) activeId = h.id; else break;
        }
        setActive(activeId);
        return activeId;
      };

      let lastActive = headings[0].id;
      setActive(lastActive);

      if ('IntersectionObserver' in window) {
        const visible = new Map();
        const update = () => {
          if (visible.size) {
            const topMost = Array.from(visible.values())
              .sort((a, b) => a.boundingClientRect.top - b.boundingClientRect.top)[0];
            lastActive = topMost.target.id;
            setActive(lastActive);
          } else {
            lastActive = fallbackCalc();
          }
        };

        const observer = new IntersectionObserver((entries) => {
          entries.forEach((entry) => {
            const id = entry.target.id;
            if (entry.isIntersecting) visible.set(id, entry);
            else visible.delete(id);
          });
          update();
        }, { rootMargin: '0px 0px -65% 0px', threshold: [0, 0.1, 0.5] });

        headings.forEach((h) => observer.observe(h));
        window.addEventListener('load', update);
        window.addEventListener('resize', update, { passive: true });
        return;
      }

      // Fallback: scroll-based detection
      let ticking = false;
      const onScroll = () => {
        if (ticking) return;
        ticking = true;
        requestAnimationFrame(() => {
          fallbackCalc();
          ticking = false;
        });
      };

      window.addEventListener('scroll', onScroll, { passive: true });
      window.addEventListener('resize', fallbackCalc, { passive: true });
      window.addEventListener('load', fallbackCalc);
      document.querySelectorAll('img').forEach((img) => img.addEventListener('load', fallbackCalc, { once: true }));
      fallbackCalc();
    })();
  </script>

  <script>
    // Lightweight lightbox for article images
    (() => {
      const imgs = Array.from(document.querySelectorAll('.article-body img'));
      if (!imgs.length) return;
      const overlay = document.createElement('div');
      overlay.className = 'lightbox-backdrop';
      overlay.innerHTML = '<img alt=\"\">';
      document.body.appendChild(overlay);
      const view = overlay.querySelector('img');
      const close = () => overlay.classList.remove('is-open');
      overlay.addEventListener('click', close);
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') close();
      });
      imgs.forEach((img) => {
        img.addEventListener('click', () => {
          view.src = img.src;
          view.alt = img.alt || '';
          overlay.classList.add('is-open');
        });
      });
    })();
  </script>

  {{ with site.Config.Services.GoogleAnalytics.ID }}
  <script>
    // GA4 Enhanced Tracking
    (() => {
      if (typeof gtag !== 'function') return;

      // 2. External link click tracking
      document.addEventListener('click', (e) => {
        const link = e.target.closest('a[href]');
        if (!link) return;
        const url = new URL(link.href, location.origin);
        if (url.hostname !== location.hostname) {
          gtag('event', 'click', {
            event_category: 'outbound',
            event_label: link.href,
            transport_type: 'beacon'
          });
        }
      });

      // 3. Scroll depth tracking (25%, 50%, 75%, 100%)
      const scrollMarks = [25, 50, 75, 100];
      const scrollFired = new Set();
      const trackScroll = () => {
        const scrollTop = window.scrollY;
        const docHeight = document.documentElement.scrollHeight - window.innerHeight;
        if (docHeight <= 0) return;
        const percent = Math.round((scrollTop / docHeight) * 100);
        scrollMarks.forEach((mark) => {
          if (percent >= mark && !scrollFired.has(mark)) {
            scrollFired.add(mark);
            gtag('event', 'scroll_depth', {
              event_category: 'engagement',
              event_label: mark + '%',
              value: mark
            });
          }
        });
      };
      let scrollTicking = false;
      window.addEventListener('scroll', () => {
        if (scrollTicking) return;
        scrollTicking = true;
        requestAnimationFrame(() => { trackScroll(); scrollTicking = false; });
      }, { passive: true });

      // 4. 404 error page tracking
      if (document.body.classList.contains('error404')) {
        gtag('event', 'page_not_found', {
          event_category: 'error',
          event_label: location.pathname + location.search,
          page_referrer: document.referrer
        });
      }

      // 5. Reading time tracking
      const startTime = Date.now();
      const sendReadTime = () => {
        const timeSpent = Math.round((Date.now() - startTime) / 1000);
        if (timeSpent > 5) { // Only track if > 5 seconds
          gtag('event', 'read_time', {
            event_category: 'engagement',
            event_label: location.pathname,
            value: timeSpent
          });
        }
      };
      window.addEventListener('beforeunload', sendReadTime);
      document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'hidden') sendReadTime();
      });

      // 6. Author social link clicks (GitHub, X, LinkedIn)
      document.addEventListener('click', (e) => {
        const link = e.target.closest('a[href]');
        if (!link) return;
        const href = link.href;
        const socialPatterns = [
          { pattern: /github\.com\/utam0k/i, platform: 'github' },
          { pattern: /x\.com\/utam0k|twitter\.com\/utam0k/i, platform: 'x' },
          { pattern: /linkedin\.com\/in\/utam0k/i, platform: 'linkedin' }
        ];
        for (const { pattern, platform } of socialPatterns) {
          if (pattern.test(href)) {
            gtag('event', 'author_social_click', {
              event_category: 'engagement',
              event_label: platform,
              link_url: href
            });
            break;
          }
        }
      });

      // 7. Share button clicks
      document.addEventListener('click', (e) => {
        const btn = e.target.closest('.share-btn, [data-share], [data-share-native]');
        if (!btn) return;
        const platform = btn.dataset.share || btn.dataset.platform || btn.getAttribute('aria-label') || 'unknown';
        gtag('event', 'share', {
          event_category: 'engagement',
          event_label: platform.toLowerCase(),
          content_type: 'article',
          item_id: location.pathname
        });
      });

      // 8. Traffic source tracking (on page load)
      const ref = document.referrer;
      const params = new URLSearchParams(location.search);
      const utmSource = params.get('utm_source') || '';
      const utmMedium = params.get('utm_medium') || '';
      const utmCampaign = params.get('utm_campaign') || '';
      let source = 'direct';
      if (utmSource) {
        source = utmSource;
      } else if (ref) {
        try {
          const refHost = new URL(ref).hostname;
          if (/google\./i.test(refHost)) source = 'google';
          else if (/bing\./i.test(refHost)) source = 'bing';
          else if (/twitter\.com|x\.com/i.test(refHost)) source = 'x';
          else if (/facebook\.com/i.test(refHost)) source = 'facebook';
          else if (/linkedin\.com/i.test(refHost)) source = 'linkedin';
          else if (/t\.co/i.test(refHost)) source = 'x';
          else source = refHost;
        } catch (e) { source = 'referral'; }
      }
      gtag('event', 'traffic_source', {
        event_category: 'acquisition',
        event_label: source,
        referrer: ref || 'direct',
        utm_source: utmSource,
        utm_medium: utmMedium,
        utm_campaign: utmCampaign
      });

      // 9. Text copy tracking
      document.addEventListener('copy', () => {
        const selection = window.getSelection()?.toString() || '';
        if (selection.length > 10) {
          gtag('event', 'text_copy', {
            event_category: 'engagement',
            event_label: location.pathname,
            text_length: selection.length
          });
        }
      });

      // 10. Internal link clicks (site navigation)
      document.addEventListener('click', (e) => {
        const link = e.target.closest('a[href]');
        if (!link) return;
        try {
          const url = new URL(link.href, location.origin);
          if (url.hostname === location.hostname && url.pathname !== location.pathname) {
            gtag('event', 'internal_link', {
              event_category: 'navigation',
              event_label: url.pathname,
              link_text: link.textContent?.trim().slice(0, 50) || '',
              from_page: location.pathname
            });
          }
        } catch (e) {}
      });

      // 11. Dark mode toggle
      const origSetTheme = window.__setTheme;
      if (origSetTheme) {
        window.__setTheme = (mode) => {
          origSetTheme(mode);
          gtag('event', 'theme_change', {
            event_category: 'preference',
            event_label: mode || document.documentElement.dataset.theme
          });
        };
      }

      // 12. Language switch
      document.addEventListener('click', (e) => {
        const link = e.target.closest('.lang-choice, [data-lang], .meta-link[href*="/en/"], .meta-link[href*="/ja/"]');
        if (!link) return;
        const href = link.href || '';
        const toLang = href.includes('/en/') ? 'en' : 'ja';
        gtag('event', 'language_switch', {
          event_category: 'preference',
          event_label: toLang,
          from_lang: document.documentElement.lang || 'unknown'
        });
      });

      // 13. TOC (Table of Contents) clicks
      document.addEventListener('click', (e) => {
        const link = e.target.closest('.toc a, .toc__body a');
        if (!link) return;
        gtag('event', 'toc_click', {
          event_category: 'navigation',
          event_label: link.textContent?.trim().slice(0, 50) || '',
          target_id: link.hash || ''
        });
      });

      // 14. RSS link clicks
      document.addEventListener('click', (e) => {
        const link = e.target.closest('a[href*="index.xml"], a[href*=".rss"], a[href*="/feed"]');
        if (!link) return;
        gtag('event', 'rss_click', {
          event_category: 'engagement',
          event_label: location.pathname
        });
      });

      // 15. Print tracking
      window.addEventListener('beforeprint', () => {
        gtag('event', 'page_print', {
          event_category: 'engagement',
          event_label: location.pathname
        });
      });
    })();
  </script>
  {{ end }}
</body>
</html>
