<!doctype html><html><head><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-119773781-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>詳解xv6 Traps, interrupts, and drivers 1 &ndash; うたもく</title><meta name=description property="og:description" content="|utam0k"><meta name=apple-mobile-web-app-title content="うたもく"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content="@utam0k"><meta name=twitter:creator content="@utam0k"><meta name=twitter:title content="詳解xv6 Traps, interrupts, and drivers 1"><meta name=twitter:image content="https://www.utam0k.jp/img/logo.jpg"><meta property="og:title" content="詳解xv6 Traps, interrupts, and drivers 1"><meta property="og:image" content="https://www.utam0k.jp/img/logo.jpg"><meta property="og:url" content="https://www.utam0k.jp/blog/2019/07/08/xv6_traps_interrupts_drivers_1/"><meta property="og:type" content="website"><meta property="og:site_name" content="うたもく"><link rel=stylesheet href=https://www.utam0k.jp/assets/syntax.css><link rel=stylesheet href=https://www.utam0k.jp/assets/style.css><link rel=stylesheet href=https://www.utam0k.jp/assets/custom_style.css><link href=https://unpkg.com/@primer/css@^16.0.0/dist/primer.css rel=stylesheet></head><body class=bg-gray><div id=holy class="container-lg bg-white h-100"><div id=header class="px-1 bg-white"><nav class="UnderlineNav UnderlineNav--right px-2"><a class="UnderlineNav-actions muted-link h2" href=https://www.utam0k.jp/>うたもく</a><div class=UnderlineNav-body><a class=UnderlineNav-item href=https://www.utam0k.jp/post/><span>Posts</span></a>
<a class=UnderlineNav-item href=https://www.utam0k.jp/page/about/><span>About</span></a>
<a class=UnderlineNav-item href=https://www.utam0k.jp/tags><span>Tags</span></a>
<a class=UnderlineNav-item href=https://www.utam0k.jp/en/><span>EN</span></a>
<a class=UnderlineNav-item href=https://www.utam0k.jp/index.xml><span>Atom</span></a></div></nav></div><div role=main id=main class="holy-main markdown-body px-4 bg-white"><div class=Subhead><div class=Subhead-heading><div class="h1 mt-3 mb-1">詳解xv6 Traps, interrupts, and drivers 1</div></div><div class=Subhead-description><a href=https://www.utam0k.jp/tags/xv6 class=muted-link><span class="Label Label--gray">xv6</span></a>
<a href=https://www.utam0k.jp/tags/os class=muted-link><span class="Label Label--gray">os</span></a><div class=float-md-right><span title="Lastmod: 2019-07-08. Published at: 2019-07-08.">Published: 2019-07-08</span></div></div></div><article><section class="pb-6 mb-3 border-bottom"><p><a href=https://www.utam0k.jp/blog/2019/03/05/xv6_index/>詳解xv6の目次</a><br><a href=https://www.utam0k.jp/blog/2019/04/25/xv6_pagetable_2/>前の記事</a>
<a href=https://www.utam0k.jp/blog/2019/12/20/xv6_scheduling_1/>次の記事</a></p><hr><p>本章では特別な役割をもったいろいろなレジスタが出現します。<br>ここでは詳しい説明を避けます<del>サボります</del>。<br>その代わりに<a href=https://ja.wikibooks.org/wiki/X86%E3%82%A2%E3%82%BB%E3%83%B3%E3%83%96%E3%83%A9/x86%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3#%E6%B1%8E%E7%94%A8%E3%83%AC%E3%82%B8%E3%82%B9%E3%82%BF_(GPR)>素晴らしい資料のリンク</a>を貼っておきます。適宜確認することをおすすめします。</p><h1 id=systems-calls-exceptions-and-interrupts>Systems calls, exceptions, and interrupts</h1><p>ユーザプログラムからカーネルに変わる3パターン</p><ol><li>システムコール(Sytem call)</li><li>例外(Exception)</li><li>割り込み(Interrupt), トラップ(Trap)</li></ol><ul><li><code>int</code>命令で呼ばれる</li><li>トラップ: 現在実行中のプロセスが発生させるもの</li><li>割り込み: 現在実行中のプロセスとは関係ない</li></ul><h1 id=x86-protection>X86 protection</h1><p><strong>$ 保護レベル</strong><br><code>%cs</code>レジスタの下位2ビットがCPLを示す</p><ul><li>DPL(Descriptor Privilege Level)</li><li>CPL(Current Privilege Level)</li></ul><p>0レベル: カーネルモード<br>3レベル: ユーザモード</p><p><strong>$ IDT</strong><br>IDT: Interrupt Descriptor Table<br>割り込みとそれに対応するハンドラのテーブル<br>カーネルはこのテーブルを作る必要がある<br><a href=http://softwaretechnique.jp/OS_Development/kernel_development02.html>詳しいおすすめ記事</a></p><p><strong>$ int命令の処理</strong></p><ul><li><p><code>int n</code>: n番目のIDTエントリの例外</p></li><li><p>処理中に<code>%cs</code> <code>%eip</code>を操作する<br><code>%cs</code> <code>%eip</code>は操作されても困らないようにする必要がある(スタックに退避させるなど)</p></li><li><p>int命令の処理手順(ハードウェアがやる)</p><ol><li>IDTからn番目のディスクリプタをフェッチ</li><li><code>%cs</code>のCPLフィールドをチェックが<code>DPL</code>以下であることを確認</li><li>ターゲットセグメントセレクタがDPL=&lt;CPLであった場合にのみ、CPUの内部レジスタである<code>%esp</code>と<code>%ss</code>を保存</li><li><code>%ss</code>と<code>%esp</code>をタスクセグメントディスクリプタからロード</li><li><code>%ss</code> <code>%esp</code> <code>%eflags</code> <code>%cs</code> <code>%eip</code>の順でスタックに積む</li><li><code>%eflags</code>の割り込み可能フラグ(IF)をクリア</li><li><code>%cs</code>と<code>%eip</code>にディスクリプタの値(詳細は5章, <code>switchuvm()</code>でTSSに値をセットしている)をセット</li></ol><blockquote><p><figure><img src=https://raw.githubusercontent.com/msyksphinz/xv6_translate/master/images/figure3-01.JPG alt=int実行後のスタックの状態><figcaption><p>int実行後のスタックの状態</p></figcaption></figure>Source: <a href=https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf>commentary/textbook</a></p></blockquote></li></ul><p><code>ret</code>ではなく<code>iret</code>命令で<code>int</code>命令のスタックを回復</p><h1 id=code-assembly-trap-handlers>Code: Assembly trap handlers</h1><p><code>main.c</code>から呼ばれる<code>tvinit()</code>でIDTのセット</p><ul><li><p><code>trap.c</code></p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=mi>17</span> <span class=kt>void</span>
<span class=mi>18</span> <span class=nf>tvinit</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
<span class=mi>19</span> <span class=p>{</span>
<span class=mi>20</span>   <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
<span class=mi>21</span>
<span class=mi>22</span>   <span class=k>for</span><span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>256</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
<span class=mi>23</span>     <span class=n>SETGATE</span><span class=p>(</span><span class=n>idt</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=mi>0</span><span class=p>,</span> <span class=n>SEG_KCODE</span><span class=o>&lt;&lt;</span><span class=mi>3</span><span class=p>,</span> <span class=n>vectors</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=mi>0</span><span class=p>);</span>
<span class=mi>24</span>   <span class=n>SETGATE</span><span class=p>(</span><span class=n>idt</span><span class=p>[</span><span class=n>T_SYSCALL</span><span class=p>],</span> <span class=mi>1</span><span class=p>,</span> <span class=n>SEG_KCODE</span><span class=o>&lt;&lt;</span><span class=mi>3</span><span class=p>,</span> <span class=n>vectors</span><span class=p>[</span><span class=n>T_SYSCALL</span><span class=p>],</span> <span class=n>DPL_USER</span><span class=p>);</span>
<span class=mi>25</span>
<span class=mi>26</span>   <span class=n>initlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tickslock</span><span class=p>,</span> <span class=s>&#34;time&#34;</span><span class=p>);</span>
<span class=mi>27</span> <span class=p>}</span> 
</code></pre></div><ul><li><p>L22-23: 256個のIDTエントリを<code>vectors</code>に対応しているハンドラにセット</p></li><li><p>L24: システムコール用のIDTエントリをセット</p></li><li><p>T_SYSCALL(=64番目のエントリ)だけはユーザレベル(∵ 第4引数がDPL_USER)で呼び出し可能</p></li><li><p>第二引数が1、つまりトラップである</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=mi>161</span> <span class=c1>// - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate.
</span><span class=c1></span><span class=mi>162</span> <span class=c1>//   interrupt gate clears FL_IF, trap gate leaves FL_IF alone
</span><span class=c1></span><span class=mi>163</span> <span class=c1>// - sel: Code segment selector for interrupt/trap handler
</span><span class=c1></span><span class=mi>164</span> <span class=c1>// - off: Offset in code segment for interrupt/trap handler
</span><span class=c1></span><span class=mi>165</span> <span class=c1>// - dpl: Descriptor Privilege Level -
</span><span class=c1></span><span class=mi>166</span> <span class=c1>//        the privilege level required for software to invoke
</span><span class=c1></span><span class=mi>167</span> <span class=c1>//        this interrupt/trap gate explicitly using an int instruction.
</span><span class=c1></span><span class=mi>168</span> <span class=err>#</span><span class=n>define</span> <span class=n>SETGATE</span><span class=p>(</span><span class=n>gate</span><span class=p>,</span> <span class=n>istrap</span><span class=p>,</span> <span class=n>sel</span><span class=p>,</span> <span class=n>off</span><span class=p>,</span> <span class=n>d</span><span class=p>)</span>                \
</code></pre></div></li><li><p><code>vectors.pl</code><br><code>vectors</code>(アセンブリ: <code>vectors.S</code>)を作るPerl製のコードジェネレータ</p><pre><code>``` perl
29 # sample output:
30 #   # handlers
31 #   .globl alltraps
32 #   .globl vector0
33 #   vector0:
34 #     pushl $0
35 #     pushl $0
36 #     jmp alltraps
37 #   ...
```
</code></pre><ul><li>L34 - 35: 後述する<code>trapframe</code>に値をセット<ul><li>L34: <code>trapframe</code>の<code>err</code>の値<br>処理によってはCPUによって自動で積まれる(e.x. PageFault)</li><li>L35: <code>trapframe</code>の<code>trapno</code>の値<br>何の処理なのかを振り分ける値(<code>trap()</code>で使われる)</li></ul></li><li>L36: 全てのvectorは<code>alltraps</code>に飛ぶ</li></ul></li><li><p><code>mmu.h</code></p><pre><code>``` c
147 // Gate descriptors for interrupts and traps
148 struct gatedesc {
149   uint off_15_0 : 16;   // low 16 bits of offset in segment
150   uint cs : 16;         // code segment selector
151   uint args : 5;        // # args, 0 for interrupt/trap gates
152   uint rsv1 : 3;        // reserved(should be zero I guess)
153   uint type : 4;        // type(STS_{IG32,TG32})
154   uint s : 1;           // must be 0 (system)
155   uint dpl : 2;         // descriptor(meaning new) privilege level
156   uint p : 1;           // Present
157   uint off_31_16 : 16;  // high bits of offset in segment
158 };
~~~
160 // Set up a normal interrupt/trap gate descriptor.
161 // - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate.
162 //   interrupt gate clears FL_IF, trap gate leaves FL_IF alone
163 // - sel: Code segment selector for interrupt/trap handler
164 // - off: Offset in code segment for interrupt/trap handler
165 // - dpl: Descriptor Privilege Level -
166 //        the privilege level required for software to invoke
167 //        this interrupt/trap gate explicitly using an int instruction.
168 #define SETGATE(gate, istrap, sel, off, d)                \
169 {                                                         \
170   (gate).off_15_0 = (uint)(off) &amp; 0xffff;                \
171   (gate).cs = (sel);                                      \
172   (gate).args = 0;                                        \
173   (gate).rsv1 = 0;                                        \
174   (gate).type = (istrap) ? STS_TG32 : STS_IG32;           \
175   (gate).s = 0;                                           \
176   (gate).dpl = (d);                                       \
177   (gate).p = 1;                                           \
178   (gate).off_31_16 = (uint)(off) &gt;&gt; 16;                  \
179 }
```
&gt; <figure>
    <img src=https://i.gyazo.com/8fa3b6b45d6da3faa39f58f1102946dc.png alt="Intel SDM Volume 3 Chapter 6"> <figcaption>
            <p>Intel SDM Volume 3 Chapter 6</p>
        </figcaption>
</figure>

</code></pre></li></ul></li></ul><p>ここまででIDEのセットが終わりました。次に実際に呼び出されたときの処理を見ていきます。<br>まずは前述したとおり、全てのハンドラは<code>alltraps</code>を呼び出します。</p><ul><li><code>alltraps</code><br>構造体<code>trapframe</code>を構築し, 構築した<code>trapframe</code>を引数として<code>trap()</code>呼び出す<ul><li><p><code>x86.h</code></p><pre><code>``` c
147 //PAGEBREAK: 36
148 // Layout of the trap frame built on the stack by the
149 // hardware and by trapasm.S, and passed to trap().
150 struct trapframe {
151   // registers as pushed by pusha
152   uint edi;
153   uint esi;
154   uint ebp;
155   uint oesp;      // useless &amp; ignored
156   uint ebx;
157   uint edx;
158   uint ecx;
159   uint eax;
160
161   // rest of trap frame
162   ushort gs;
163   ushort padding1;
164   ushort fs;
165   ushort padding2;
166   ushort es;
167   ushort padding3;
168   ushort ds;
169   ushort padding4;
170   uint trapno;
171
172   // below here defined by x86 hardware
173   uint err;
174   uint eip;
175   ushort cs;
176   ushort padding5;
177   uint es;
178
179   // below here only when crossing rings, such as from user to kernel
180   uint esp;
181   ushort ss;
182   ushort padding6;
183 };
```
`alltraps`が呼び出される時点でL182 - 169まではスタックに積んである状態
</code></pre></li><li><p><code>trapasm.S</code></p><pre><code>``` c
 3   # vectors.S sends all traps here.
 4 .globl alltraps
 5 alltraps:
 6   # Build trap frame.
 7   pushl %ds
 8   pushl %es
 9   pushl %fs
10   pushl %gs
11   pushal
12
13   # Set up data segments.
14   movw $(SEG_KDATA&lt;&lt;3), %ax
15   movw %ax, %ds
16   movw %ax, %es
17
18   # Call trap(tf), where tf=%esp
19   pushl %esp
20   call trap
21   addl $4, %esp
22
23   # Return falls through to trapret...                                                              
24 .globl trapret
25 trapret:
26   popal
27   popl %gs
28   popl %fs
29   popl %es
30   popl %ds
31   addl $0x8, %esp  # trapno and errcode
32   iret
```
- L6 - 11: `trapframe`を構築  
- L15 - 16: データセグメントをセットする
  - `%ds`: データセグメント
  - `%es`: エクストラセグメント  

  &gt; <figure>
    <img src=https://i.gyazo.com/4359a1ecc77942c016a757401ac0a4f6.jpg alt=L16でのスタックの状態> <figcaption>
            <p>L16でのスタックの状態</p>
        </figcaption>
</figure>

  Source: [commentary/textbook](https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf)

- L18 - 20: `trap()`を作ったtrap構造体を引数にして呼び出す
  - L19: trapへの引数として構築した`trapframe`構造体のポイント(現在の`%esp`)を渡す
  - L20: 呼び出し  
  - L21: trapへの渡した引数(L19)を`%esp`を加算することでpop
- L26 - 30: L6 - 11のも巻き戻し
- L31: trapnoとerrorcodeをスキップ
- L32: `iret`
  - Interrupt Return
  - pop `%cs` `%eip` `%flags` `%esp` `%ss`(異なる特権へのリターンのため)
  - 中断していたプログラム(スタックに積まれているアドレス)を再開
</code></pre></li></ul></li></ul><h1 id=code-c-trap-handler>Code: C trap handler</h1><ul><li><p><code>trap()</code>
<code>alltraps</code>から呼ばれる</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=mi>36</span> <span class=c1>//PAGEBREAK: 41
</span><span class=c1></span><span class=mi>37</span> <span class=kt>void</span>
<span class=mi>38</span> <span class=n>trap</span><span class=p>(</span><span class=k>struct</span> <span class=n>trapframe</span> <span class=o>*</span><span class=n>tf</span><span class=p>)</span>
<span class=mi>39</span> <span class=p>{</span>
<span class=mi>40</span>   <span class=k>if</span><span class=p>(</span><span class=n>tf</span><span class=o>-&gt;</span><span class=n>trapno</span> <span class=o>==</span> <span class=n>T_SYSCALL</span><span class=p>){</span>
<span class=mi>41</span>     <span class=k>if</span><span class=p>(</span><span class=n>myproc</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>killed</span><span class=p>)</span>
<span class=mi>42</span>       <span class=n>exit</span><span class=p>();</span>
<span class=mi>43</span>     <span class=nf>myproc</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>tf</span> <span class=o>=</span> <span class=n>tf</span><span class=p>;</span>
<span class=mi>44</span>     <span class=nf>syscall</span><span class=p>();</span>
<span class=mi>45</span>     <span class=nf>if</span><span class=p>(</span><span class=n>myproc</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>killed</span><span class=p>)</span>
<span class=mi>46</span>       <span class=n>exit</span><span class=p>();</span>
<span class=mi>47</span>     <span class=k>return</span><span class=p>;</span>
<span class=mi>48</span>   <span class=p>}</span>
<span class=mi>49</span>
<span class=mi>50</span>   <span class=k>switch</span><span class=p>(</span><span class=n>tf</span><span class=o>-&gt;</span><span class=n>trapno</span><span class=p>){</span>
            <span class=p>.</span>
            <span class=p>.</span>
            <span class=p>.</span>
</code></pre></div><p>IDTエントリにセットされているハンドラで積まれている<code>trapno</code>によって処理を振り分ける</p></li></ul><h1 id=code-system-calls>Code: System calls</h1><p>ここでは<code>trap()</code>から呼び出されるのがシステムコールの場合の処理を追っていきます。<br>まずは最初のシステムコールの呼び方みてxv6でのシステムコールの呼び方を見ていきます。(該当の章は Code: The first system call)</p><ul><li><p><code>initcode.S</code></p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=mi>8</span> <span class=err>#</span> <span class=n>exec</span><span class=p>(</span><span class=n>init</span><span class=p>,</span> <span class=n>argv</span><span class=p>)</span>
<span class=mi>9</span> <span class=p>.</span><span class=n>globl</span> <span class=n>start</span>
<span class=mi>10</span> <span class=nl>start</span><span class=p>:</span>
<span class=mi>11</span>   <span class=n>pushl</span> <span class=err>$</span><span class=n>argv</span>
<span class=mi>12</span>   <span class=n>pushl</span> <span class=err>$</span><span class=n>init</span>
<span class=mi>13</span>   <span class=n>pushl</span> <span class=err>$</span><span class=mi>0</span>  <span class=c1>// where caller pc would be
</span><span class=c1></span><span class=mi>14</span>   <span class=n>movl</span> <span class=err>$</span><span class=n>SYS_exec</span><span class=p>,</span> <span class=o>%</span><span class=n>eax</span>
<span class=mi>15</span>   <span class=kt>int</span> <span class=err>$</span><span class=n>T_SYSCALL</span>
</code></pre></div><ul><li>L11 - 12: 引数をスタックに積む</li><li>L13: システムコールから戻るときのアドレスをスタックに積む<ul><li>最初のシステムコールのため戻ってくることはないため適当な値</li><li><code>call</code>命令は自動的に戻るときのアドレスをスタックに積む</li></ul></li><li>L14: <code>%eax</code>に該当するシステムコールの番号を格納</li><li>L15: <code>int</code>でシステムコールを呼び出し</li></ul></li></ul><p>xv6のシステムコールの処理を追っていきます。<br>前述した<code>trap()</code>から<code>syscall()</code>が呼ばれたところからです。</p><ul><li><p><code>syscall.c</code></p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=mi>131</span> <span class=kt>void</span>
<span class=mi>132</span> <span class=nf>syscall</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
<span class=mi>133</span> <span class=p>{</span>
<span class=mi>134</span>   <span class=kt>int</span> <span class=n>num</span><span class=p>;</span>
<span class=mi>135</span>   <span class=k>struct</span> <span class=n>proc</span> <span class=o>*</span><span class=n>curproc</span> <span class=o>=</span> <span class=n>myproc</span><span class=p>();</span>
<span class=mi>136</span>
<span class=mi>137</span>   <span class=n>num</span> <span class=o>=</span> <span class=n>curproc</span><span class=o>-&gt;</span><span class=n>tf</span><span class=o>-&gt;</span><span class=n>eax</span><span class=p>;</span>
<span class=mi>138</span>   <span class=k>if</span><span class=p>(</span><span class=n>num</span> <span class=o>&gt;</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>num</span> <span class=o>&lt;</span> <span class=n>NELEM</span><span class=p>(</span><span class=n>syscalls</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>syscalls</span><span class=p>[</span><span class=n>num</span><span class=p>])</span> <span class=p>{</span>
<span class=mi>139</span>     <span class=n>curproc</span><span class=o>-&gt;</span><span class=n>tf</span><span class=o>-&gt;</span><span class=n>eax</span> <span class=o>=</span> <span class=n>syscalls</span><span class=p>[</span><span class=n>num</span><span class=p>]();</span>
<span class=mi>140</span>   <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
<span class=mi>141</span>     <span class=n>cprintf</span><span class=p>(</span><span class=s>&#34;%d %s: unknown sys call %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
<span class=mi>142</span>             <span class=n>curproc</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=n>curproc</span><span class=o>-&gt;</span><span class=n>name</span><span class=p>,</span> <span class=n>num</span><span class=p>);</span>
<span class=mi>143</span>     <span class=n>curproc</span><span class=o>-&gt;</span><span class=n>tf</span><span class=o>-&gt;</span><span class=n>eax</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
<span class=mi>144</span>   <span class=p>}</span>
<span class=mi>145</span> <span class=p>}</span>
</code></pre></div><ul><li>L137: <code>trapframe</code>の<code>%eax</code>から該当するシステムコールの番号を取り出し呼ぶ</li><li>L139, 143: 返り値を<code>trapframe</code>の<code>%eax</code>に格納<ul><li><p>システムコールは<code>%eax</code>に返り値が格納されている</p></li><li><p>L143: エラー時の処理</p></li><li><p>L139: システムコールの実行</p><pre><code>``` c
107 static int (*syscalls[])(void) = {
108 [SYS_fork]    sys_fork,
109 [SYS_exit]    sys_exit,
110 [SYS_wait]    sys_wait,
111 [SYS_pipe]    sys_pipe,
112 [SYS_read]    sys_read,
113 [SYS_kill]    sys_kill,
114 [SYS_exec]    sys_exec,
          .
          .
          .
```
</code></pre></li></ul></li></ul></li><li><p>引数のヘルパー関数: <code>argint()</code><br>前提: システムコールの呼び出しはスタック(<code>tf->esp</code>)に積まれている</p><ul><li><p>使われ方の例</p><pre><code>``` c
286 int
287 sys_open(void)
288 {
289   char *path;
290   int fd, omode;
291   struct file *f;
292   struct inode *ip;
293
294   if(argstr(0, &amp;path) &lt; 0 || argint(1, &amp;omode) &lt; 0)
295     return -1;
```
- L294: 
  - 第1引数: 何個目の引数か
  - 第2引数: 引数の値を入れる変数
</code></pre></li><li><p><code>syscall.c</code></p><pre><code>``` c
48 // Fetch the nth 32-bit system call argument.
49 int
50 argint(int n, int *ip)
51 {
52   return fetchint((myproc()-&gt;tf-&gt;esp) + 4 + 4*n, ip);
53 }
``` 
- L52: 
  - `+4`: `call`命令で積まれた戻るためのアドレスが格納されている
  - `+4*n`: 該当の引数まで
</code></pre></li><li><p><code>syscall.c</code></p><pre><code>``` c
16 // Fetch the int at addr from the current process.
17 int
18 fetchint(uint addr, int *ip)
19 {
20   struct proc *curproc = myproc();
21
22   if(addr &gt;= curproc-&gt;sz || addr+4 &gt; curproc-&gt;sz)
23     return -1;
24   *ip = *(int*)(addr);
25   return 0;
26 }
```
</code></pre><ul><li>L22: ユーザー空間からの引数なので注意が必要</li><li>L24: 読み込む</li></ul></li></ul></li><li><p>他にも<code>argptr()</code> <code>argstr()</code> <code>argfd()</code>などある</p></li></ul><h1 id=exercises>Exercises</h1><p><a href=https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf>commentary/textbook</a>
についてる問題の僕の回答を載せておきます。</p><blockquote><p>Add a new system call to get the current UTC time and return it to the user program. You may want to use the helper function, cmostime (7552), to read the real time clock. The file date.h contains the definition of the struct rtcdate (0950), which you will provide as an argument to cmostime as a pointer.</p></blockquote><p><a href=https://gist.github.com/utam0k/1c04a96d7d1f16885f85562a5747bcf7>回答gist</a></p><p>次回は<code>trap()</code>から呼び出されるのが割り込みだった場合の処理、ドライバを追っていきます。</p><hr><p>コメントや間違いなどがある場合は<a href=https://twitter.com/utam0k>Twitter</a>に連絡してもらうか
<a href=https://github.com/utam0k/utam0k.github.io/issues/1>Issue</a>に書いていただくと助かります</p></section><section><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"utam0k"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></section></article></div><div id=side class="pr-1 bg-white"><aside class=pr-3><div id=toc class="Box Box--blue mb-3"><b>詳解xv6 Traps, interrupts, and drivers 1</b><nav id=TableOfContents></nav></div><div><a href="https://twitter.com/share?ref_src=twsrc%5Etfw" class=twitter-share-button data-show-count=false>Tweet</a><script async src=https://platform.twitter.com/widgets.js></script>
<iframe src="https://www.facebook.com/plugins/share_button.php?href=https%3A%2F%2Fdevelopers.facebook.com%2Fdocs%2Fplugins%2F&layout=button&size=small&mobile_iframe=true&width=61&height=20&appId" width=61 height=20 style=border:none;overflow:hidden scrolling=no frameborder=0 allowtransparency=true allow=encrypted-media></iframe>
<a href=http://b.hatena.ne.jp/entry/ class=hatena-bookmark-button data-hatena-bookmark-layout=basic-label-counter data-hatena-bookmark-lang=ja title=このエントリーをはてなブックマークに追加><img src=https://b.st-hatena.com/images/entry-button/button-only@2x.png alt=このエントリーをはてなブックマークに追加 width=20 height=20 style=border:none></a><script type=text/javascript src=https://b.st-hatena.com/js/bookmark_button.js async></script></div></aside></div><div id=footer class="pt-2 pb-3 bg-white text-center"></div></div><script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type=text/x-mathjax-config>MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });</script></body></html>